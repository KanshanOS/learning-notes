# 物理设计
---


### 一、定义数据库、表及字段的命名规范

> 数据库、表及字段的命名要遵守**可读性原则**、**表意性原则**、**长名原则**

### 二、选择合适的存储引擎
| 存储引擎 | 事务 | 锁粒度 | 主要应用 | 忌用 |
| ------- | ---- | ------ | ------- | ---- |
| InnoDB | 支持 | 支持MVCC的行级锁 | 事务处理 | 无 |
| MyISAM  | 不支持 | 支持并发插入的表级锁 | select、insert | 读写操作频繁 |
| MRG_MyISAM | 不支持 | 支持并发插入的表级锁 | 分段归档，数据仓库 | 全局查找过多的场景 |
| Archive | 不支持 | 行级锁 | 日志记录，只支持insert、select | 需要随机读取、更新及删除 |
| Ndb cluster | 支持  | 行级锁 | 高可用性 | 大部分应用 |

### 三、为表中的字段选择合适的数据类型
#### 1.原则
> 当一个列可以选择多种数据类型是，应当优先考虑数字类型，其次是日期或二进制类型，最后是字符串类型。对于相同级别的数据类型，应该有效选择占用空间小的数据类型
> 
>  **数字类型  >  日期、二进制  >  字符串**

#### 2.整数类型
| 列类型 | 存储空间 | 范围（有符号）| 范围（无符号）| 
| ------ | ------- | ------------ | ------------ | 
| tinyint | 1 字节  | -128 ~ 127  | 0 ~ 255       | 
| smallint| 2 字节  | -32 768 ~ 32 767 | 0 ~ 65 535 |
| mediumint| 3 字节 | -8 388 608 ~ 8 388 607 | 0 ~ 16 777 215 |
| int/integer| 4 字节 | -2 147 483 648 ~ 2 147 483 647 | 0 ~ 4 294 967 295 |
| bigint | 8 字节 | -9 233 372 036 854 775 808 ~ 9 223 372 036 854 775 807 | 0 ~ 18 446 744 073 709 551 615 |


#### 3.实数类型
| 列类型 | 存储空间 | 是否精确| 
| ------ | ------- | ------ | 
| float  | 4 字节  | 否     |
| double | 8 字节  | 否     |
| decimal| 每4个字节存9个数字，小数点占一个字节 | 是 |

#### 4.VARCHER、CHAR 类型
> utf8 字符集为例，存储10个字符的话列定义为`VARCHAR(10)`、`CHAR(10)` 而不是 ~~`VARCHAR(30)`~~、~~`CHAR(30)`~~

##### a). VARCHAR、CHAR 类型的存储特点
- varchar 用于存储变长的字符串，只占用必要的存储空间
- 列的最大长度小于**255**则只占用一个额外字节用于记录字符串长度
- 列的最大长度大于**255**则要占用两个额外字节用于记录字符创长度

##### b).VARCHAR、CHAR 类型的选择
1.VARCHAR 的长度选择
> - 使用最小的符合需求的长度：MySQL 5.7 之前修改表结构需锁表；5.7之后若原长度在**255**以内，且修改后长度也在**255**以内则不锁表，否则同样需要锁表
> - varchar(5)、varchar(200)存储 “MySQL” 字符串性能不同：MySQL优化查询时会使用固定宽度，例如创建查询临时表时，需要更多的内存

2.VARCHAR 的适用场景
> - 字符串咧的最大长度比平均长度大很多
> - 字符串列很少被更新
> - 使用了utf8等多字节字符集存储的字符串
 
3.CAHR 的特点
> - CHAR 类型是定长的
> - 字符串存储在CHAR类型的列中会删除末尾空格，VARCHAR不会删除
> - CHAR 类型的最大宽度为**255**，超过则使用VARCHAR

4.CAHR 的适用场景
> - 长度近似的值：手机号、身份证
> - 短字符串：性别
> - 经常更新的字符串：流转状态
>

#### 4.日期数据
1.DATETIME 类型
> - 以 YYYY-MM-DD HH:MM:SS[.fraction] 格式存储日期时间
>       datetime = YYYY-MM-DD HH:MM:SS
>       datetime(6) = YYYY-MM-DD HH:MM:SS[.fraction] (存储微秒)
> - DATETIME 类型与时区无关，占用8个字节的存储空间
> - 时间范围 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59

2.TIMESTAMP 类型
> - 存储由格林尼治时间1970年1月1日到当前时间的秒数
> - 以 YYYY-MM-DD HH:MM:SS[.fraction] 的格式显示
> - 占用4个字节，实际存储为 `int`
> - 时间范围 1970-01-01 ~ 2038-01-19
> - 显示依赖于所指定的时区
> - 在行的数据修改时可以自动修改`timestamp`列的值，默认第一列`timestamp`可自动更新，也可通过建表语句指定：可用于记录数据修改的时间

3.DATE、TIME类型（MySQL5.7 之后）
> 1. DATE类型
>   - 占用自己鹅湖比使用字符串、datetime、int 存储要少，使用date类型只需要三个字节
>   - 使用DATE类型还可利用日期时间函数进行日期之间的计算
>   - 范围 1000-01-01 ~ 9999-12-31 
> 2. TIME类型
>   - 英语存储时间数据，格式为 HH:MM:SS

4.注意事项
> 1. 不要使用字符串类型来存储日期时间数据：a.日期时间类型通常比字符串占用的存储空间小;b.日期时间类型在进行查找过滤时可以利用日期来进行对比;c.日期时间类型还有着丰富的处理喊出，可以方便的对其进行日期计算
> 2. 使用int存储日期时间不如使用timestamp类型：本身即为int存储，但是展示时更易读


### 四、总结

> **如何为InnoDB选择主键?**
 - 主键应该尽可能的小：因为每一个非主键索引都会附加主键的信息，如果我们主键非常大的话，会使索引变慢，影响查询效率
> - 主键应该是顺序增长的：避免了随机IO的产生，增加数据的插入效率。如果主键不能保证顺序增长，则有可能每次插入后都有可能进行随机排序，会带来额外的IO消耗
> - InnoDB的主键和业务主键可以不同：为了保证业务主键的唯一性，可以设置唯一索引







