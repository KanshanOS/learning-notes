# synchronized 关键字

## 基本概念

**Java 底层对可见性、有序性、原子性的保证**

- **可见性** - 基于 MESI 协议 flush、refresh 配合使用，才可以解决可见性问题
- **有序性** - 三个层次，最后一个层次有 4 钟重排（`LoadLoad`、`LoadStore`、`StoreLoad`、`StoreStore`）
- **原子性** - 基本的赋值写操作都是可以保证原子性的，复杂的操作是无法保证原子性的



**synchronized 关键字可以同时保证：可见性、有序性、原子性**

- **原子性** - 加锁和释放锁的机制，加了锁之后，同一段代码同时就只有一个线程可以执行

- **可见性** - 在同步代码块对变量进行写操作之后，会在释放锁的时候强制执行 `flush` 操作，在进入代码块的时候，对变量的读操作都会全部执行 `refresh` 操作

- **有序性** - synchronized 关键字通过加各种内存屏障解决 `LoadLoad` 、`StoreStore` 等重排序。进入 synchronized 后加 Acquire 内存屏障，退出 synchronized 前加 Release 内存屏障禁止指令重排，但是 **synchronized 代码块内部的代码还是可能会出现指令重排**，synchronized 指令重排的定义为：**synchronized 代码块内部的代码与外部的代码不发生指令重排**



**synchronized 原子性实现的核心原理**

加锁和释放锁，ObjectMonitor

![20_synchronized细化底层原理](images/20_synchronized%E7%BB%86%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.jpg)

> 整体实现原理类似于 `ReentrantLock` 基于：`状态码`、`当前锁被占用的线程`、`等待加锁的线程队列`



## Java 虚拟机对锁的优化：锁消除、锁粗化、偏向锁、自旋锁

### 锁消除

锁消除是JIT编译器对synchronized锁做的优化，在编译的时候，JIT会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被一个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不用加入monitorenter和monitorexit的指令

这就是，仅仅一个线程争用锁的时候，就可以消除这个锁了，提升这段代码的执行的效率，因为可能就只有一个线程会来加锁，不涉及到多个线程竞争锁

### 锁粗化

这个意思就是，JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁，就是锁粗化，把一个锁给搞粗了，避免频繁多次加锁释放锁

### 偏向锁

这个意思就是说，monitorenter和monitorexit是要使用CAS操作加锁和释放锁的，开销较大，因此如果发现大概率只有一个线程会主要竞争一个锁，那么会给这个锁维护一个偏好（Bias），后面他加锁和释放锁，基于Bias来执行，不需要通过CAS

此优化性能会提升很多，但是如果有偏好之外的线程来竞争锁，就要收回之前分配的偏好。可能只有一个线程会来竞争一个锁，但是也有可能会有其他的线程来竞争这个锁，但是其他线程唉竞争锁的概率很小，如果有其他的线程来竞争这个锁，此时就会收回之前那个线程分配的那个Bias偏好

### 轻量级锁

如果偏向锁没能成功实现，就是因为不同线程竞争锁太频繁了，此时就会尝试采用轻量级锁的方式来加锁，就是将对象头的Mark Word里有一个轻量级锁指针，尝试指向持有锁的线程，然后判断一下是不是自己加的锁

如果是自己加的锁，那就执行代码就好了

如果不是自己加的锁，那就是加锁失败，说明有其他人加了锁，这个时候就是升级为重量级锁

### 适应性锁（自旋锁）

这是JIT编译器对锁做的另外一个优化，如果各个线程持有锁的时间很短，那么一个线程竞争锁不到，就会暂停，发生上下文切换，让其他线程来执行。但是其他线程很快释放锁了，然后暂停的线程再次被唤醒

也就是说在这种情况下，线程会频繁的上下文切换，导致开销过大

所以对这种线程持有锁时间很短的情况，是可以采取忙等策略的，也就是一个线程没竞争到锁，进入一个while循环不停等待，不会暂停不会发生线程上下文切换，等到机会获取锁就继续执行好了

这样可以大幅度减少线程上下文的切换，而这种自旋等待获取锁的方式，就是所谓自旋锁，就是不断的自旋尝试获取锁

如果一个线程持有锁的时间很长，那么其他线程获取不到锁，就会暂停，发生上下文切换，让其他线程来执行，这种自己暂停获取锁的方式，就是所谓的重量级锁

这个根据不同情况自动调整的过程，就是适应锁的意思